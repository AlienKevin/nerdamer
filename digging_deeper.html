<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Nerdamer | Digging deeper</title>

    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="css/site.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="./img/favicon.png">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="./plugins/highlightjs/styles/vs.css"> 
    <script src="./plugins/highlightjs/highlight.pack.js"></script> 
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-58729441-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="./"><img src="./img/logo.png" alt="Nerdamer"/></a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="./">Home</a>
                    </li>
                    <li>
                        <a href="./documentation.html">Documentation</a>
                    </li>
                    <li>
                        <a href="./demo.html">Demo</a>
                    </li>
                    <li>
                        <a href="./quickstart.html">Quick Start</a>
                    </li>
                    <li class="visible-sm visible-xs"><a href="./extending_core.html">Extending the core</a></li>
                    <li class="visible-sm visible-xs active"><a href="./digging_deeper.html">Digging deeper</a></li>
                    <li class="visible-sm visible-xs"><a href="./examples.html">Examples</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

        <hr>

        <div class="row">
            <div class="col-sm-9">
                <h1>Digging deeper</h1>
                <h3>Understanding the grouping</h3>
                <p>
                    If you've ever had to do complex calculations or tried to implement a serious algorithm, you may have noticed some of the challenges
                    of doing math with JavaScript. In the case of symbolic math one of those challenges is the inability to do any form of operator overloading. 
                    It's far easier to look at and use 4*x^2 then it is to use something like multiply('4', pow('x', '2')). Another downside is that because
                    the primary datatype has to be a string if you're to have anything resembling 4*x^2, your overhead is quite high.
                </p>
                <p>
                    Nerdamer employs a somewhat unorthodox way of representing polynomials, and symbols. It still helps to have an understanding of polynomial rings and domains, and 
                    the more conventional way of doing things but for the most part it will be used implicitly.
                </p>
                <p>
                    Nerdamer uses a grouping system and a unified way of representing symbols. Symbols are represented as a multiplier, a value, and a power, {multiplier}*{base}^{power}.
                    The symbols are then grouped into 8 groups.
                </p>
                <ol>
                    <li><strong>N: </strong> This groups is just a vanilla number.</li>
                    <li><strong>P: </strong> This groups is a number raised to a number power e.g. 2^(3/5). Integer powers are generally converted to N right away. </li>
                    <li><strong>S: </strong> This groups is basically a variable. x, s, y^2 </li>
                    <li><strong>EX: </strong> This groups is any symbol raised to a variable power. Basically exponential functions.</li>
                    <li><strong>FN: </strong> This groups is just a function. e.g. cos(x), abs(x)</li>
                    <li><strong>PL: </strong> This groups is any recurring symbol through addition differing only in power e.g. x+x^2, cos(x)+cos(x)^y. If the base is the same they get grouped into this group.</li>
                    <li><strong>CB: </strong> This groups is a multivariate monomial. A group of symbols held together through multiplication x*y*t^2</li>
                    <li><strong>CP: </strong> This groups is similar to PL but the bases are different e.g. r+t, x+1</li>
                </ol>
                <p>
                    It's tempting to call the PL group and CP group polynomials but remember they don't discriminate based on power so x^(-1)+x will make the cut. To check if a symbol 
                    is a valid polynomial special functions have to be used.
                </p>
                <p>
                    The benefit of this system is that it allows us to leverage JavaScript object lookup rather that loop and search.
                    take this example
                </p>
<pre>Symbol {
    x: {x+x^2},
    y: {y^2}
}</pre>
                <p>
                    If we are to add a symbol x then the lookup goes something like: Look for x in symbol. If x is found and it's not of group S then it's of group PL and 
                    see if this power already exists. If it does, add them otherwise create a new entry within x.
                </p>
                <p>
                    One major benefit of this representation vs and array based representation comes when evaluating polynomials with large powers. 
                    Given the polynomial x^5 for instance JavaScript would represent it as 
                </p>
                <pre>x: [,,,,,1] </pre>
                <p>
                    with the zero 
                    index being the constants. You can quickly see how a polynomial in the form of
                </p>
                <pre>x^10000000000*x^10000000000</pre> 
                <p>
                    can quickly take a browser to its knees vs the group method. The group method has some major inefficiencies mainly when dealing with cases such as 
                    polynomial long division, GCD computations, etc. In this case nerdamer switches to the array based representation. At this point we have bigger
                    concerns, mainly integer overflow.
                </p>
                <h3>Symbol representation</h3>
                <p>
                    Symbols are also represented in a simplified uniform matter. At the very least a symbol contains a multiplier, a value, a power, and a group. This is what the number 1 looks like:
                </p>
                <pre>
{ 
    group: 1,
    value: '#',
    multiplier: 
    { [Number: 1]
        num: { [Number: 1] value: 1, sign: false, isSmall: true },
        den: { [Number: 1] value: 1, sign: false, isSmall: true } 
    },
    power: 
    { [Number: 1]
       num: { [Number: 1] value: 1, sign: false, isSmall: true },
       den: { [Number: 1] value: 1, sign: false, isSmall: true } 
    } 
}
                </pre>
                <p>
                    The power and multiplier are integer ratios of the bigNumber class. All numbers have a value of '#'. Other symbols carry their variable minus the power and multiplier as their value
                    which is why x^2 can be group with x^3, etc. All symbols have a multiplier of class Frac. All symbols with the exception of group EX have a power of the class Frac as well. 
                    EX have a symbol as their power. If udring an operation the symbol's power results in a number, nerdamer will automatically convert
                    the group out of the EX group and the power back to class Frac. The goal is always keep the simplest and most compatible form.
                </p>
                <h3>Parsing</h3>
                <p>
                    To perform the actual parsing of the string, nerdamer uses the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a>. While parsing
                    several classes are utilized to accommodate functions, vectors, matrices, and special operators. It's also important to note that the nodes get collapsed as soon as possible.
                    Additionally operators return 1 of the existing symbols. This was an early design decision which initially helped speed things up a bit but that may have since changed. The most 
                    important thing to remember is that when using symbols in subsequent calculations the clone method should be used to get a clean copy. For example:
                </p>
                <pre>
<code>
//You can interact with the parser directly by getting the core
//with nerdamer loaded either in a web page or node.js
var core = nerdamer.getCore();
//the parser can be accessed in the core through PARSER. 
//Make a shortcut using underscore
var _ = core.PARSER;
//the parser requires objects of class Symbol
var Symbol = core.Symbol;
//create a symbol
var x1 = new Symbol('x');
//one more
var x2 = new Symbol('x');
//add them using the parser
var result = _.add(x1, x2);
//in this case x1 was recycled
console.log(result === x1); //true
</code></pre>
                <p>
                    This only becomes a concern when directly interacting with Symbols. When parsing strings a fresh Symbol is created each time.
                </p>
                <h3>Function handling</h3>
                <p>
                    I've covered how to set custom functions in <a href="">Extending the core</a> but that doesn't cover how nerdamer deals with functions.
                    While parsing nerdamer first looks at the PARSER.functions object. This object let's the parser know which functions are available. The entry should 
                    contain 2 items. The first being the symbolic handler if any (not all functions have this) and the second is how may arguments to expect. If left blank
                    the parser will first search for that function in the built-in Math object and if it comes up empty it will search in the Math2 object, and object created
                    especially for adding custom functions. The Math2 object should only contain numeric functions since this is the function which will get exported when 
                    the buildFunction method is called. Let's look at an example.
                </p>
<pre><code>
//You can interact with the parser directly by getting the core
//with nerdamer loaded either in a web page or node.js
var core = nerdamer.getCore();
//the parser can be accessed in the core through PARSER. 
//Make a shortcut using underscore
var _ = core.PARSER;
//when parsing the function first looks into the built-in Math object
//and then into the Math2 object
//add a custom function
core.Math2.custom = function(a, b) {
    return (2*a+b)/a;
};
//let nerdamer know that it's ok to access this function
//we do that using an array. The first parameter is the special handler
//which we'll leave blank for now. This will only give it numeric capabilities
_.functions.custom = [,2];
//we can now use the function
var x = nerdamer('custom(2, 6)').evaluate();
console.log(x.toString()); //5
//It can't handle symbolics as illustrated next
var y = nerdamer('custom(a, b)').evaluate();
console.log(y.toString()); //custom(a, b)                 
</code></pre>
                <p>
                    To enable symbolic capabilities we use the above example but provide the definition with a symbol handler.
                </p>
<pre><code>
var core = nerdamer.getCore();
var _ = core.PARSER;
core.Math2.custom = function(a, b) {
    return (2*a+b)/a;
};
//symbolic handler
function symbolicHandler(a, b) {
    //for simplicity we'll work stricly with the Symbol class
    //Remember earlier we spoke of calling clone? In this case the A !== a
    //but it's good practice to call clone on values that are going to be reused
    //If a was to become 2*a then we'd also be dividing by 2*a and not a
    var A = _.multiply(new core.Symbol(2), a.clone());
    var B =_.add(A, b);
    return _.divide(B, a);
};
//let nerdamer know that it's ok to access this function
//we do that using an array. The first parameter is the special handler
//which we'll leave blank for now. This will only give it numeric capabilities
_.functions.custom = [symbolicHandler,2];
//we can now use the function
var x = nerdamer('custom(2, 6)').evaluate();
console.log(x.toString()); //5
//It can't handle symbolics as illustrated next
var y = nerdamer('custom(a, b)').evaluate();
console.log(y.toString()); //(2*a+b)*a^(-1)          
</code></pre>
                <p>
                    Now in the above example we divide by a which can be zero. Let's imagine for a second, and this is a completely contrived example chosen for simplicity, that
                    division by zero resulted in a imaginary number. We can add a special handler for this in the symbolic handler.
                </p>
<pre><code>
var core = nerdamer.getCore();
var _ = core.PARSER;
core.Math2.custom = function(a, b) {
    return (2*a+b)/a;
};
//symbolic handler
function symbolicHandler(a, b) {
    //we do a check and return a special value for a === 0
    if(a.equals(0)) {
        //the value for imaginary numbers is stored in core.Settings.IMAGINARY
        //this should be used in case the user decides to use something different
        //like j for example
        return new core.Symbol(core.Settings.IMAGINARY);
    }
    //for simplicity we'll work stricly with the Symbol class
    //Remember earlier we spoke of calling clone? In this case the A !== a
    //but it's good practice to call clone on values that are going to be reused
    //If a was to become 2*a then we'd also be dividing by 2*a and not a
    var A = _.multiply(new core.Symbol(2), a.clone());
    var B =_.add(A, b);
    return _.divide(B, a);
};
//let nerdamer know that it's ok to access this function
//we do that using an array. The first parameter is the special handler
//which we'll leave blank for now. This will only give it numeric capabilities
_.functions.custom = [symbolicHandler,2];
//we can now use the function
var x = nerdamer('custom(0, 2)').evaluate();
console.log(x.toString()); //i
var y = nerdamer('custom(9, 3)').evaluate();
console.log(y.toString());//7/3
var z = nerdamer('custom(x, y)');
console.log(z.toString());//(2*x+y)*x^(-1)             
</code></pre>
                <p>
                    It might be apparent to you by now that you have no commitment to any of the built-in functions and you are completely at liberty to override any or 
                    all of them. If you have another library who's version of cos you like, you can just override it using the above example and nerdamer will gladly use 
                    that one instead. This gives you the option of using nerdamer as a purely symbolic layer.
                </p>
                <h3>Custom operators</h3>
                <p>
                    You can set custom operators to a degree. Below is an example of how to accomplish this.
                </p>
<pre><code>
var core = nerdamer.getCore();
var _ = core.PARSER;
//see core source code for full explanation or parameters. In this case just know
//The first param is the operator character so the parser can recognize it
//The second is the name of the parser function that it maps to
//The third is the order in which to parse first. e.g. an order of 5 will get parsed before 4.
//The fourth is if it's left associative. 
//The fifth is if it's a prefix operator
//And the last is if it's a postfix operator
var Operator = core.Operator;
//create a blank operator so the operator knows it's an operator 
//because the parser only sees one character at a time. We don't define anything in this
//case since it's a dummy operator to let nerdamer know that it should be treated as one.
_.operators['<'] = new Operator('<');
//create the operator you want and we'll name it bitleft. It's up to you. Just make
//sure you call it the same as the function defined below. 
_.operators['<<'] = new Operator('<<', 'bitleft', 1, true, false);
//define the function
_.bitleft = function(a, b) {
    return a << b;
}; 
//we can now use it.
var x = nerdamer('5<<2');
console.log(x.toString()); //20               
</code></pre>
                <p>More coming soon ...</p>
            </div>
            <div class="col-sm-3 hidden-sm hidden-xs">
                <ul class="side-bar">
                    <li class="active"><a href="./extending_core.html">Extending the core</a></li>
                    <li><a href="./digging_deeper.html">Digging deeper</a></li>
                    <li><a href="./examples.html">Examples</a></li>
                </ul>     
            </div>
        </div>

        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12 text-center">
                    <p>Copyright &copy; Nerdamer.com <span class="date"></span></p>
                </div>
            </div>
            <!-- /.row -->
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>
    <script>
        $('.date').html(new Date().getFullYear());
    </script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>
